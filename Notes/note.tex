\documentclass [12 pt, twoside] {article}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codeblue}{rgb}{0,0,0.6}
\definecolor{backcolor}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor = \color{backcolor},
	commentstyle = \color{codeblue},
	keywordstyle = \color{codegreen},
	numberstyle = \color{codegray},
	stringstyle = \color{magenta},
	basicstyle = \footnotesize,
	breakatwhitespace = false,
	breaklines = true,
	captionpos = b,
	keepspaces = true,
	numbers = left,
	numbersep = 5pt,
	showspaces = false,
	showstringspaces = false,
	showtabs = false,
	tabsize = 4
}

\lstset{style = mystyle}

\begin{document}

\title{APCS Notes}
\author{Yicheng Wang}
\date{2014-2015}

\maketitle
\newpage
\setcounter{tocdepth}{3}
\tableofcontents
\newpage

\section{2014-9-8}


\subsection{Comparison of Programming Languages}
\newline
\textbf{Scheme}:
\newline Annoying Prefix Notation
\newline strict syntax
\newline not object oriented
\newline only seperated by parenthesis
\newline IDE NOT necessary
\newline Mostly recursion + list
\newline Functional Programming Language (Everything is a function)
\newline
\newline
\textbf{Netlogo}:
\newline GUI based
\newline Shines on Interactive Modeling
\newline Bad for input/output data
\newline Parallel Programming Language
\newline Not a general-purpose language -- ONLY USEFUL IN NETLOGO ENVIROMENT
\newline Netlogo IDE (Integrated Development Enviroment) NECESSARY
\newline
\newline
\textbf{Python}:
\newline High-level Language
\newline Uses Indentation
\newline infixed math + prefix function
\newline Linear processing
\newline General-purpose language
\newline Interperted Language
\newline IDE NOT necessary
\newline
\newline
\textbf{Java}:
\newline Object oriented
\newline infixed math + prefix function
\newline Mid-level Language
\newline
\newline
$\LaTeX$
\newline Markup Language
\newline Compiled Language

\newpage
\section{2014-9-10}
\subsection{"Hello World" in Java}


Last year, we learned how to write the "Hello World" program in python.
\begin{lstlisting}[language=Python]
def hello():
	print "Hello world!"

hello()
\end{lstlisting}


Now, we'll learn about how to do this in Java:


Java is more restrictive than python, java programs are usually in their own folders.
Java's invented for portability and "amount of stupid/super-smart people."
Different smart people have different ways of approaching problems.
Java's designed to limit people's ways of doing things to make big project easy.
Real good programmers don't like java... b/c it's restrictive.
Java is designed to be industrially viable.


An object defines a specific thing within your program.
Everything in java is an object.
\newline A Class = object type.
\newline Tradition = 1 class per file, named starting with upper-case letter


Here's a simple program in Java:
\begin{lstlisting}[language=Java]
/*
	This is a null line
	C'est un comment!
*/

// C'est un end-of-line comment

import java.io.*;
import java.util.*;

public class Hello {  // public = the outside world (aka other things in your program) can see this
	public static void main(String[] args) {
		System.out.println("Hello World");
	}
}
\end{lstlisting}


\subsection{Running Java}
Source code (foo.java) $\to$ Java compiler (foo.class) $\to$ JVM
\newline Note that java doesn't compile to machine code, java compiles to javaBiteCode using JVM. This is where the portability comes in.


\subsection{Java technicalities}
method = function in python
\newline You  need a method in one of you're classes called "main"


\section{2014-9-11}
\subsection{Moving into the "java way" of doing things!}


Java is object oriented.
Object oriented means that the world is made of objects.
Every object has its unique attributes.
Objects also have abilities, aka things they can do.
Every program in java is made of objects.


Let's take the example of a simple chess program.
An example of an object would be a pawn.
It would have attributes like color and position.
Its abilities would include moving and attacking.
However, these pawns are different, White pawn 1-8 and Black pawn 1-8.
They behave in the same way, but they have different positions.
You don't want 16 seperate definitions b/c most of them are the same.
Therefore one would create a class for all of the pawns, which would define the "info about objects."
We then make objects which are known as "instances of a class."
Objects are made based on the definitions defined within the class.


Hello world program #2 -- the java way:
\begin{lstlisting}[language=Java]
// We'll use objects to do stuff

import java.io.*;
import java.util.*;

public class Greeter {
	// We put the attributes here

	// We put the abilities here
	// In Java, these are called methods
	// Methods are functions, but they belong to specific classes
	public void greet() {
	
	// public = can be called from outside the class
	// void = this doesn't send anything back, like null returner in C
 
		System.out.println("Hello world!");
	}
}
\end{lstlisting}

\section{2014-9-15}
\subsection{Typical anatomy of Java Program}


A program is consisted of objects.
One must tell java where to start the program --> public static void main
One calls that class "driver," it starts the java program.


Driver.java:
\begin{lstlisting}[language=Java]

import java.io.*;
import java.util.*;

public class Driver {
	public static void main(String[] args) {
		
		//How to use the greeter within the driver.
		
		Greeter g;
		//Creates a local variable to be of type greeter

		/*
		Variable declaration, all variables must be declared
		like global, turtles-own and patches-own variables in netlogo
		Declaration specifies the type of the variable
		local variable = a variable only visible/usable within a method, created when the method is called, destroyed when the function exits
		*/

		/*
		When main is ran, it occupies some memory on the computer
		Greeter g is a small box within main, we need to do something with it
		or java refuses to do stuff with it
		*/

		g = new Greeter();
		/*
		New:
		 1. Allocates enough memory to store a Greeter.
		 2. Do whatever's necessary to setup / initiates the memory to be a Greeter.
		 3. Returns the address of the memory that was allocated.

		 The assignment statement stores the address in g.
		*/

		System.out.println(g);
		
		// This prints the location of the variable g within the memory

		/*
		When this file is compiled, Greeter is compiled as well
		All methods/class called during main are compiled as well
		*/

		g.greet();
		/*
		Accesses the greet method within the class g.
		*/
	}
}
\end{lstlisting}
\section{2014-9-17}
\subsection{Instance vs Local variable}


The instance variable is defined within the class and can be called from outside (if public) as well as methods w/i the class.
Note that local variable within the methods overshadow instance variables of the same name.
To assign a public instance variable from an outside object is: <objectName>.<variable name> = new <Variable Type> <variable value>;
Instance variables are like turtle variables in NetLogo.


Instance Variables: Declared in class otside the methods. Usually at the top.
Each instance (object) of the class has its own copy of the instance variables.


Ex.
\begin{lstlisting}[language=java]
public class Driver {
	public static void main(String[] args) {
		Greeter g1 = new Greeter();
		g1.greeting = new String("Sup!");
		g1.greet();
	}
}
\end{lstlisting}


In here, the Driver class assigns the instance variable "greeting" a new value.
If greeting is set to private, the above code will not work.
In java, we almost NEVER make instance variables public so you can't assign them from outside.
Instead, we write public "set" methods within the class which then assigns the private instance variable.
"Set" methods will be covered in detail next time.


\section{2014-9-18}
\subsection{Setter Function}


A setter function edits a private instance variable from within its own class.
An example follows:
\begin{lstlisting}[language=java]
public class Greeter4 {
	private String greeting = new String ("Hello World!");
	public void greet() {
		//	String greeting = new String("Sup!");
		System.out.println(greeting);
	}
	public void setGreeting(String s) { // This is the setter function
		greeting = s;
	}
	public void ungreet() {
		System.out.println("I'm out!'");	
	}
}
\end{lstlisting}


\subsection{Return Type}


In java, the name after public/private specifies the return type.
A method can return any type of value (String, Int, even custom classes).
When the function doesn't return any value, the type is "void"


An example getter method follows:
\begin{lstlisting}[language=java]
	
	\\ blah stuff above

	public void setGreeting(String s) {
		greeting = s;
	}

	\\blah stuff below
\end{lstlisting}


Note that when the getter function is called, it is tantamount to a STRING!
It can be used whenever a string is used.


\subsection{Style Stuff}


Stylisticly speaking, in most languages, we should usually avoid using void and print stuff.
However, they should return a value and then be printed in the main function.


\subsection{Constructor Functions}


These functions are called only when new objects are declared.
Constructor functions are always public, its name is the name of the class, and there's no return value (NOT VOID, simply NO return value).
This will be called when you run the new statemet.


Note that once we write a constructor, we lose the default constructor.
This means all assignments must have a set parameter list.
We solve this problem via overloading.
We'll make multiple constructors, for example, we make 2 constructors, one with a String parameter while the other one doesn't have a parameter.


\section{2014-9-19}
\subsection{Full Anatomy of a Java Program}


Super generic java code of a class:
\begin{lstlisting}[language=Java]
import java.io.*; // import pacakges (iff you need them)

public class genericClass { // class name, camelTyped, same name as file
	// instance variables

	private String s; // instance variables are almost always private
	
	private String s2 = "hello"; // Declaration and assignment can be done at once
	
	private String s3,s4,s5; // multiple declaration seperated by commas

	// constructors <- called automatically on "new"

	public genericClass(String s) { // ALWAYS PUBLIC and NO RETURN VALUE
		// do stuff here!
	}
	
	public genericClass() { // Constructors can be overloaded
		// do stuff!
	}

	// methods

	public void method1(params) {
		blah;
	}

	private String method2(params) {
		blah2;
	}
}
\end{lstlisting}


\subsection{work!}


Write a method greetPerson, which takes 1 parameter (name) and appends the name to the greeting.


Write another method called "LOUD GREET," which returns greet in AllCaps.


\section{2014-9-22}
\subsection{string literal vs new function}


Let's look at the following code:
\begin{lstlisting}[languge = Java]
	public void test1() {
		String s1 = "hello";
		String s2 = "hello";
		String s3 = new String("hello");
		String s4 = new String("hello");
		System.out.println("s1 == s2:" + (s1 == s2));
		System.out.println("s1 == s3:" + (s1 == s3));
		System.out.println("s1 == s4:" + (s1 == s4));
		System.out.println("s2 == s3:" + (s2 == s3));
		System.out.println("s2 == s4:" + (s2 == s4));
		System.out.println("s3 == s4:" + (s3 == s4));
	}
\end{lstlisting}


When run, everything except the first line returns false.
This is because of the different means of variable assignment.
When s1 is assigned, java creates a block of memory to store the sting "hello."
When s2 is assigned, java checks for the existance of "hello" and finds the memory block of s1.
Then s2 is assigned to the same memory as s1.
Therefore s2 equals to s1.
However, new function doesn't check pre-existing "hello" but creates a new memory block.
Therefore the memory location of s1,s3, and s4 are all different.


\subsection{string methods}
\subsubsection{.equals(<string>) method:}


It compares the literal value of the string instead of the memory location.


\subsubsection{.equalsIgnoreCase(<string) method:}


Same as .equals, but ignores case


\subsubsection{.compareTo(<string>) method:}


It's like a dictionary ordering.
Returns 0 if the original object is equal to the new string
\newline
Returns > 0 if the original object is greater than the new string
\newline
Returns < 0 if the original object is less than the new string


\subsubsection{.contains(<string>) method}:


Returns if the new stirng is w/i the old string.


\subsubsection{.endswith(<string>) and .startswith(<string>)}


As the name suggests, ends with blah and starts with blah


\subsubsection{.isEmpty()}


Returns true if the sting is empty. False otherwise.
\end{document}
