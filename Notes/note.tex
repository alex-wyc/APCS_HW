\documentclass [12 pt, twoside] {article}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codeblue}{rgb}{0,0,0.6}
\definecolor{backcolor}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor = \color{backcolor},
	commentstyle = \color{codeblue},
	keywordstyle = \color{codegreen},
	numberstyle = \color{codegray},
	stringstyle = \color{magenta},
	basicstyle = \footnotesize,
	breakatwhitespace = false,
	breaklines = true,
	captionpos = b,
	keepspaces = true,
	numbers = left,
	numbersep = 5pt,
	showspaces = false,
	showstringspaces = false,
	showtabs = false,
	tabsize = 4
}

\lstset{style = mystyle}

\begin{document}

\title{APCS Notes}
\author{Yicheng Wang}
\date{2014-2015}

\maketitle
\newpage
\setcounter{tocdepth}{3}
\tableofcontents
\newpage

\section{2014-9-8}


\subsection{Comparison of Programming Languages}
\newline
\textbf{Scheme}:
\newline Annoying Prefix Notation
\newline strict syntax
\newline not object oriented
\newline only seperated by parenthesis
\newline IDE NOT necessary
\newline Mostly recursion + list
\newline Functional Programming Language (Everything is a function)
\newline
\newline
\textbf{Netlogo}:
\newline GUI based
\newline Shines on Interactive Modeling
\newline Bad for input/output data
\newline Parallel Programming Language
\newline Not a general-purpose language -- ONLY USEFUL IN NETLOGO ENVIROMENT
\newline Netlogo IDE (Integrated Development Enviroment) NECESSARY
\newline
\newline
\textbf{Python}:
\newline High-level Language
\newline Uses Indentation
\newline infixed math + prefix function
\newline Linear processing
\newline General-purpose language
\newline Interperted Language
\newline IDE NOT necessary
\newline
\newline
\textbf{Java}:
\newline Object oriented
\newline infixed math + prefix function
\newline Mid-level Language
\newline
\newline
$\LaTeX$
\newline Markup Language
\newline Compiled Language

\newpage
\section{2014-9-10}
\subsection{"Hello World" in Java}


Last year, we learned how to write the "Hello World" program in python.
\begin{lstlisting}[language=Python]
def hello():
	print "Hello world!"

hello()
\end{lstlisting}


Now, we'll learn about how to do this in Java:


Java is more restrictive than python, java programs are usually in their own folders.
Java's invented for portability and "amount of stupid/super-smart people."
Different smart people have different ways of approaching problems.
Java's designed to limit people's ways of doing things to make big project easy.
Real good programmers don't like java... b/c it's restrictive.
Java is designed to be industrially viable.


An object defines a specific thing within your program.
Everything in java is an object.
\newline A Class = object type.
\newline Tradition = 1 class per file, named starting with upper-case letter


Here's a simple program in Java:
\begin{lstlisting}[language=Java]
/*
	This is a null line
	C'est un comment!
*/

// C'est un end-of-line comment

import java.io.*;
import java.util.*;

public class Hello {  // public = the outside world (aka other things in your program) can see this
	public static void main(String[] args) {
		System.out.println("Hello World");
	}
}
\end{lstlisting}


\subsection{Running Java}
Source code (foo.java) $\to$ Java compiler (foo.class) $\to$ JVM
\newline Note that java doesn't compile to machine code, java compiles to javaBiteCode using JVM. This is where the portability comes in.


\subsection{Java technicalities}
method = function in python
\newline You  need a method in one of you're classes called "main"


\section{2014-9-11}
\subsection{Moving into the "java way" of doing things!}


Java is object oriented.
Object oriented means that the world is made of objects.
Every object has its unique attributes.
Objects also have abilities, aka things they can do.
Every program in java is made of objects.


Let's take the example of a simple chess program.
An example of an object would be a pawn.
It would have attributes like color and position.
Its abilities would include moving and attacking.
However, these pawns are different, White pawn 1-8 and Black pawn 1-8.
They behave in the same way, but they have different positions.
You don't want 16 seperate definitions b/c most of them are the same.
Therefore one would create a class for all of the pawns, which would define the "info about objects."
We then make objects which are known as "instances of a class."
Objects are made based on the definitions defined within the class.


Hello world program #2 -- the java way:
\begin{lstlisting}[language=Java]
// We'll use objects to do stuff

import java.io.*;
import java.util.*;

public class Greeter {
	// We put the attributes here

	// We put the abilities here
	// In Java, these are called methods
	// Methods are functions, but they belong to specific classes
	public void greet() {
	
	// public = can be called from outside the class
	// void = this doesn't send anything back, like null returner in C
 
		System.out.println("Hello world!");
	}
}
\end{lstlisting}

\section{2014-9-15}
\subsection{Typical anatomy of Java Program}


A program is consisted of objects.
One must tell java where to start the program --> public static void main
One calls that class "driver," it starts the java program.


Driver.java:
\begin{lstlisting}[language=Java]

import java.io.*;
import java.util.*;

public class Driver {
	public static void main(String[] args) {
		
		//How to use the greeter within the driver.
		
		Greeter g;
		//Creates a local variable to be of type greeter

		/*
		Variable declaration, all variables must be declared
		like global, turtles-own and patches-own variables in netlogo
		Declaration specifies the type of the variable
		local variable = a variable only visible/usable within a method, created when the method is called, destroyed when the function exits
		*/

		/*
		When main is ran, it occupies some memory on the computer
		Greeter g is a small box within main, we need to do something with it
		or java refuses to do stuff with it
		*/

		g = new Greeter();
		/*
		New:
		 1. Allocates enough memory to store a Greeter.
		 2. Do whatever's necessary to setup / initiates the memory to be a Greeter.
		 3. Returns the address of the memory that was allocated.

		 The assignment statement stores the address in g.
		*/

		System.out.println(g);
		
		// This prints the location of the variable g within the memory

		/*
		When this file is compiled, Greeter is compiled as well
		All methods/class called during main are compiled as well
		*/

		g.greet();
		/*
		Accesses the greet method within the class g.
		*/
	}
}
\end{lstlisting}
\section{2014-9-17}
\subsection{Instance vs Local variable}


The instance variable is defined within the class and can be called from outside (if public) as well as methods w/i the class.
Note that local variable within the methods overshadow instance variables of the same name.
To assign a public instance variable from an outside object is: <objectName>.<variable name> = new <Variable Type> <variable value>;
Instance variables are like turtle variables in NetLogo.


Instance Variables: Declared in class otside the methods. Usually at the top.
Each instance (object) of the class has its own copy of the instance variables.


Ex.
\begin{lstlisting}[language=java]
public class Driver {
	public static void main(String[] args) {
		Greeter g1 = new Greeter();
		g1.greeting = new String("Sup!");
		g1.greet();
	}
}
\end{lstlisting}


In here, the Driver class assigns the instance variable "greeting" a new value.
If greeting is set to private, the above code will not work.
In java, we almost NEVER make instance variables public so you can't assign them from outside.
Instead, we write public "set" methods within the class which then assigns the private instance variable.
"Set" methods will be covered in detail next time.


\section{2014-9-18}
\subsection{Setter Function}


A setter function edits a private instance variable from within its own class.
An example follows:
\begin{lstlisting}[language=java]
public class Greeter4 {
	private String greeting = new String ("Hello World!");
	public void greet() {
		//	String greeting = new String("Sup!");
		System.out.println(greeting);
	}
	public void setGreeting(String s) { // This is the setter function
		greeting = s;
	}
	public void ungreet() {
		System.out.println("I'm out!'");	
	}
}
\end{lstlisting}


\subsection{Return Type}


In java, the name after public/private specifies the return type.
A method can return any type of value (String, Int, even custom classes).
When the function doesn't return any value, the type is "void"


An example getter method follows:
\begin{lstlisting}[language=java]
	
	\\ blah stuff above

	public void setGreeting(String s) {
		greeting = s;
	}

	\\blah stuff below
\end{lstlisting}


Note that when the getter function is called, it is tantamount to a STRING!
It can be used whenever a string is used.


\subsection{Style Stuff}


Stylisticly speaking, in most languages, we should usually avoid using void and print stuff.
However, they should return a value and then be printed in the main function.


\subsection{Constructor Functions}


These functions are called only when new objects are declared.
Constructor functions are always public, its name is the name of the class, and there's no return value (NOT VOID, simply NO return value).
This will be called when you run the new statemet.


Note that once we write a constructor, we lose the default constructor.
This means all assignments must have a set parameter list.
We solve this problem via overloading.
We'll make multiple constructors, for example, we make 2 constructors, one with a String parameter while the other one doesn't have a parameter.


\section{2014-9-19}
\subsection{Full Anatomy of a Java Program}


Super generic java code of a class:
\begin{lstlisting}[language=Java]
import java.io.*; // import pacakges (iff you need them)

public class genericClass { // class name, camelTyped, same name as file
	// instance variables

	private String s; // instance variables are almost always private
	
	private String s2 = "hello"; // Declaration and assignment can be done at once
	
	private String s3,s4,s5; // multiple declaration seperated by commas

	// constructors <- called automatically on "new"

	public genericClass(String s) { // ALWAYS PUBLIC and NO RETURN VALUE
		// do stuff here!
	}
	
	public genericClass() { // Constructors can be overloaded
		// do stuff!
	}

	// methods

	public void method1(params) {
		blah;
	}

	private String method2(params) {
		blah2;
	}
}
\end{lstlisting}


\subsection{work!}


Write a method greetPerson, which takes 1 parameter (name) and appends the name to the greeting.


Write another method called "LOUD GREET," which returns greet in AllCaps.


\section{2014-9-22}
\subsection{string literal vs new function}


Let's look at the following code:
\begin{lstlisting}[language=Java]
public class genericClass {
	public void test1() {
		String s1 = "hello";
		String s2 = "hello";
		String s3 = new String("hello");
		String s4 = new String("hello");
		System.out.println("s1 == s2:" + (s1 == s2));
		System.out.println("s1 == s3:" + (s1 == s3));
		System.out.println("s1 == s4:" + (s1 == s4));
		System.out.println("s2 == s3:" + (s2 == s3));
		System.out.println("s2 == s4:" + (s2 == s4));
		System.out.println("s3 == s4:" + (s3 == s4));
	}
}
\end{lstlisting}


When run, everything except the first line returns false.
This is because of the different means of variable assignment.
When s1 is assigned, java creates a block of memory to store the sting "hello."
When s2 is assigned, java checks for the existance of "hello" and finds the memory block of s1.
Then s2 is assigned to the same memory as s1.
Therefore s2 equals to s1.
However, new function doesn't check pre-existing "hello" but creates a new memory block.
Therefore the memory location of s1,s3, and s4 are all different.


\subsection{string methods}
\subsubsection{.equals(<string>) method:}


It compares the literal value of the string instead of the memory location.


\subsubsection{.equalsIgnoreCase(<string) method:}


Same as .equals, but ignores case


\subsubsection{.compareTo(<string>) method:}


It's like a dictionary ordering.
Returns 0 if the original object is equal to the new string
\newline
Returns > 0 if the original object is greater than the new string
\newline
Returns < 0 if the original object is less than the new string


\subsubsection{.contains(<string>) method}:


Returns if the new stirng is w/i the old string.


\subsubsection{.endsWith(<string>) and .startsWith(<string>)}


As the name suggests, ends with blah and starts with blah


\subsubsection{.isEmpty()}


Returns true if the sting is empty. False otherwise.


\section{2014-9-23}
\subsection{Tour of Primitive Stuff in Java}
\subsubsection{primitive data types}


Java has classes of Strings and any class we write.
Java also have primitive data types:


\newline


\begin{tabular}{|c|l|}
\hline
int & integers \\
\hline
double & double-percision integers \\
\hline
char & single character \\
\hline
boolean & true/false \\
\hline
\end{tabular}


\newline


Strings and primitive data types work a bit differently.
Every data we make on a 32-bit computer, the memory block assigned is a 32-bit blocks.
The 32-bit block is called "work bit size."
Any primitive type (their actual value) is stored in the variable's own memory location.
Whereas class types, the variable's own memory location only stores the link to the actual class somewhere else in the memory.
This is because one does not know how large a class can be.
For example, on a 16-bit computer, if strings were stored as a primitive data type, the string can be most 4 letters.
Therefore, to solve the problem with strings with arbitiary length, we only put a pointer within the class variable.


However, one must be careful with the types.
Java is really strict about type operations.
For example, 5.0 / 2.0 returns 2.5.
However, 5 / 2 returns 2.
Bottom line is that one should not mix int and double


\subsubsection{If Statements}


Basic form of if in java:
\begin{lstlisting}[language = Java]

public class blah {

	public void blah1() {
		if (<boolean>) {
			<insert statements here if the boolean is true>
		}
		else if (<boolean2>){
			<insert statements here if the boolean1 is false and boolean2 is true>
		}
		else {
			<insert statements here if both booleans are true>
		}
	}

}

\end{lstlisting}


A list of comparison operators:


Just everything in python, except double ampersand is and and double pipe is or.


\section{2014-9-30}
\subsection{loops}


Loop means doing stuff over and over again until something are met.
We technically don't need loops, because recursion can replace loop anytime.


Examples of loop in languages:
\begin{itemize}
	\item Netlogo forever button
	\item Netlogo while loop
	\item Netlogo repeat loop
	\item Python for loop
	\item Python while loop
\end{itemize}


While loops can be thought as repeated if statements.
In Java, the while loop is perfectly analogous to the python while.
\begin{lstlisting}[language=java]

	Codes

	while (<boolean>) {
		<statements>;
	}

	More codes.

\end{lstlisting}


\section{2014-10-06}
\subsection{Software Development}


Class dungeon crawl game -- Stuyablo! Example = nethack.
We'll talk about our version of dungeon crawl.
You have different types of entities:
\begin{enumerate}
	\item Monsters
		\begin{itemize}
			\item Attribute: inventory
			\item Attribute: Armor
			\item Attribute: Strength
		\end{itemize}
	\item Wizard
		\begin{itemize}
			\item Attribute: HP
			\item Attribute: XP
			\item Attribute: Level
			\item Attribute: Mano
			\item Attribute: Intellect
		\end{itemize}
	\item Warriors
		\begin{itemize}
			\item Attribute: Weapon
			\item Attribute: Shield
			\item Attribute: Strength
			\item Attribute: Range
		\end{itemize}
	\item Rogue
		\begin{itemize}
			\item Attribute: HP -- Medium/Low
			\item Attribute: Speed -- High
			\item Attribute: Agility -- High
			\item Attribute: Luck -- High
			\item Attribute: Accuracy -- High
			\item Attribute: Power -- Low
			\item Attribute: Intellect -- High
			\item Attribute: Charisma -- Medium/Low
			\item Ability: Pickpocket
			\item Ability: Poison/Assisinate
			\item Alignment: 0--3
		\end{itemize}
	\item Cleric
		\begin{itemize}
			\item Attribute: HP
			\item Attribute: XP
			\item Attribute: Mano
			\item Attribute: Healing power
		\end{itemize}
\end{enumerate}


Each of these will have certain attributes and abilities.
But some of them have common things, like health, inventory, etc.
However, something like Manna are not the same for everything.
Warriors, thiefs don't have Manna.
We can say the same for abilities that all should have -- attack,
defend, eat, pick up. However, things like spell-casting, pickpocket,
etc. should be character-specific.


For flexibility, java has \textbf{Class Inherentence}. Which means
that one class can be based on or is an extension of another class.
So we can make a class called "characters" with instance variables
being the common abilities and attributes (XP, Level, attack, pick-up, 
etc.) Then using class inherentence we can create specific character types.


Class Inherentence Example:
\begin{lstlisting}

\\ BaseChar.java
public class BaseChar {
	private int hp = 20;

	public int getHp() {
		return hp;
	}
}

\\ Wizard.java
public class extend BaseChar {

}

\\ Wizard will have everything character has
\end{lstlisting}


\section{2014-10-7}
\subsection{Subclass and Superclass}


Referring to yesterday's code, the BaseChar class is called
the superclass of Wizard. And Wizard is called the
subclass of BaseChar. Note that the subclass only has access
to the public instance variables. Therefore, the inherent class
can only call public functions.


\textbf{overriding}: When a subclass has a variable or method of the same name 
and signature as a method/variable in the superclass. Thus overriding
the thing in the superclass.


In order to access the superclass, we use super.<method> to access
stuff that's been overridden.


\section{2010-10-8}
\subsection{More Inheritence Stuff}


A superclass can be referred to any of its subclasses. However, it can
only call the overridden methods. It cannot get extended methods.


\textbf{Casting}: call extended methods from superclass. Example:
\begin{lstlisting}[language=java]

	Basechar c = new Basechar();
	Mage m1 = new Mage();
	Basechar c1;

	c1 = m1;

	((Mage)c1).getManna();

\end{lstlisting}


The parenthesis is important because usually the "." operator takes precedence of the
casting operator.


More local stuff overwrite less local stuff. In order to specify
explicitly the instance variables, you use this.<instance var>.


Now suppose we get an attack method. We want
to attack a basechar. Since all characters are
extensions of Basechar. Ex. code:

\begin{lstlisting}[language=java]

	public void attack(Basechar other){
		System.out.println(getName() + "attacked" other.getName());
	}

\end{lstlisting}


\section{2014-10-9}
\subsection{Constructors and Inheritence}


In order for a subclass to work, it needs to have everything set up
for it in the superclass. Whenever one makes a subclass, it first
calls the superclass constructor. It will also do so automatically.
So you need to write each constructor at each level. If we don't
explicitly call the super constructor, i.e. super(); as the first
line of our subclass' constructor, java will call the superclass'
default constructor. Therefore, use super to specify what will be done.


Example Code:
\begin{lstlisting}[language=java]

public class Superclass {
	
	private String name;

	public Superclass() {
		setName("DEFAULT");
	}

	public Superclass(String n) {
		setName(n);
	}

	public void setName(String n) {
		name = n;
	}
}

public class Subclass extends Superclass {

	public Subclass() {
		super();
		// This will set the name as "DEFAULT"
	}

	public Subclass(String name) {
		super(name);
		// This will set the name as the parameter "name"
	}
}
\end{lstlisting}


\section{2014-10-24}


\subsection{Array Stuff}


Basic array declaration format: <type>[] <name> = new <type>[<length>].
"Type" is the type of stuff that'll be stored within the array called <name>, like
"int" "String" etc.
Another more straight forward way of declaring arrays is to just type it after the equal sign.
For example:
\begin{lstlisting}[language=java]

String[] message = new String[5] // string called message with 5 places

for (i = 0 ; i < 5 ; i++) {
	message[i] = blah;
}
\end{lstlisting}


\section{2014-10-27}
\subsection{Class Stuff -- Static and Final}


When one tries to access an instance variable within the same class,
instance variables can't be used because the class is technically
not refering to itself. To use the stuff within the same class, you
do have to declare a new instance of the class within itself.


Final variables are variables whose values cannot be cahnged. For example
<array>.length() is a final variable. These variables can be used but
cannot be assigned or changed.

\section{2014-11-10}

\subsection{Exception Handeling}


In java, error are known as exceptions. When exceptions occur, they crash the program
and and returns an exception debugging message. However, we can create our own exception
handeling mechanism. Note that each exception is a class and can be called throughout the
program, as seen below:


\begin{lstlisting}[language=java]
public EE {
	public void etest(int i) {
		if (i > 10) {

			throw new ArithmeticException();
		}
	}
}

// New Class!

public Driver {

	public static void main(String[] args) {
		EE ee = new EE();
	}

	System.out.println("Before the test");

	EE.etest(1);
	EE.etest(11);

	System.out.println("After the test");
}
\end{lstlisting}


Note how EE.etest(11); crashed the program with the ArithmeticException.


However, we can make the error message more useful by using a try-catch block. This
construct will stop the program as soon as an error occurs and pause the program. The
syntax of class Driver is as follows:


\begin{lstlisting}[language=java]
public Driver {

	public static void main(String[] args) {
		EE ee = new EE();
	}

	System.out.println("Before the test");

	try {
		ee.etest(11);
		System.out.println("etest has been run");
	}

	catch (Exception e) {
		System.out.println("etest crashed with Error: " + e);
	}

	System.out.println("After the test");
}
\end{lstlisting}

Note that catch prevents crashing of the program, instead it just send an
error message. Also note that the "Exception e" parameter can be replaced
by any specific error class such as ArrayIndexOutOfBoundsException or 
ArithmeticException, etc. It is also possible to stack a few catch phrases
one after another to expect multiple types of errors.


It is important to note that try-catch construct should NOT be used to conceal
errors from crashing the program. It should be used for cases in which java's
compiler is being dumb, and gives error for things that can be fixed.
\end{document}
